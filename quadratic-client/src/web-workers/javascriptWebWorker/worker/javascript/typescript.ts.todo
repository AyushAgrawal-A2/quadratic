export class Javascript {

  ...

  init = async () => {
    await esbuild.initialize({
      wasmURL: '/esbuild.wasm',
      // this would create another worker to run the actual code. I don't
      // think this is necessary but it's an option.
      worker: false,
    });
  }

  ...

  run() {
    let buildResult: esbuild.BuildResult;

    // Show an error if the user attempts to import modules (not yet supported)
    if (transform.imports !== ';') {
      const codeResult: JsCodeResult = {
        transaction_id: message.transactionId,
        success: false,
        output_value: null,
        std_err: 'Javascript import statements are not supported yet',
        std_out: null,
        output_array: null,
        line_number: null,
        output_display_type: null,
        cancel_compute: false,
      };
      javascriptCore.sendJavascriptResults(message.transactionId, codeResult);
      javascriptClient.sendState('ready');
      this.state = 'ready';
      setTimeout(this.next, 0);
      return;
    }

    Keep track of all logs and warnings.
    let oldConsoleLog = console.log;
    let oldConsoleWarn = console.warn;
    javascriptConsole.reset();
    console.log = javascriptConsole.consoleMap;
    console.warn = javascriptConsole.consoleMap;

    Build the code to convert TS to Javascript and wrap it in an async
    wrapper to enable top-level await. First, we try the naive line number
    variable.
    try {
      buildResult = await esbuild.build({
        stdin: {
          contents: prepareJavascriptCode(transform, this.withLineNumbers),
          loader: 'js',
        },

        format: 'esm',
        bundle: false,
        write: false,
      });
      if (buildResult.outputFiles?.length) {
        code = buildResult.outputFiles[0].text;
        // Uncomments the below lines to see what the transpiled code looks
        // like. The library needs to be kept consistent with
        // javascriptLibrary#javascriptLibraryWithoutComments.
        //
        // oldConsoleLog(code);
      }
    } catch (e) {
      // try it without the line number variable
      if (this.withLineNumbers) {
        this.run(message, false);
        return;
      }

      // Catch any build errors and use them as the return result.
      const failure = e as esbuild.BuildFailure;
      const codeResult: JsCodeResult = {
        transaction_id: message.transactionId,
        success: false,
        output_value: null,
        std_err: failure.errors
          .map(
            (e) =>
              `${e.text} ${
                e.location ? `on line ${e.location.line - javascriptLibraryLines + 1}:${e.location.column}` : ''
              }`
          )
          .join('\n'),
        std_out: null,
        output_array: null,
        line_number: null,
        output_display_type: null,
        cancel_compute: false,
      };
      javascriptCore.sendJavascriptResults(message.transactionId, codeResult);
      javascriptClient.sendState('ready');
      this.state = 'ready';
      console.log = oldConsoleLog;
      console.warn = oldConsoleWarn;
      setTimeout(this.next, 0);
      return;
    }

    if (buildResult.warnings.length > 0) {
      javascriptConsole.push(buildResult.warnings.map((w) => w.text));
    }
    let calculationResult: any, lineNumber: number | undefined;
  }
}